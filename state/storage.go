package state

import (
	"bytes"
	"compress/gzip"
	"context"
	"fmt"
	"io"
	"log"
	"time"

	"cloud.google.com/go/storage"
)

// gzCompress compress and add comment.
// Returns compressed data.
func gzCompress(data []byte, comment string) ([]byte, error) {
	var buf bytes.Buffer
	zw := gzip.NewWriter(&buf)
	zw.Comment = comment

	_, err := zw.Write(data)
	if err != nil {
		return nil, err
	}
	if err := zw.Close(); err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// writeDataToBucket compress and write bytes to a bucket object.
// Returns unique state ID.
func writeDataToBucket(data []byte, bucket, user string) (string, error) {
	log.Printf("raw state size: %d bytes.", len(data))
	id, key, err := GetUniqueObjectID(bucket)
	if err != nil {
		return "", fmt.Errorf("creating unique ID: %v", err)
	}

	data, err = gzCompress(data, fmt.Sprintf("Generated by user: %v", user))
	if err != nil {
		return "", fmt.Errorf("compression error: %v", err)
	}

	_, err = writeObject(data, bucket, key, true)
	if err != nil {
		return "", fmt.Errorf("write error: %v", err)
	}
	return id, nil
}

// writeObject write bytes to a bucket object.
// Returns number of bytes written.
func writeObject(data []byte, bucket, key string, create bool) (int, error) {
	ctx := context.Background()
	client, err := storage.NewClient(ctx)
	if err != nil {
		return 0, err
	}
	defer client.Close()

	obj := client.Bucket(bucket).Object(key)
	if create {
		obj = client.Bucket(bucket).Object(key).If(
			storage.Conditions{DoesNotExist: true})
	}

	w := obj.NewWriter(ctx)
	n, err := w.Write(data)

	if err != nil {
		return 0, err
	}

	// close immediately to confirm object has been created.
	if err := w.Close(); err != nil {
		return 0, fmt.Errorf(
			"at Close(): error writing to object %v: %v", obj.ObjectName(), err)
	}
	var action string = "updated"
	if create {
		action = "created"
	}
	log.Printf("%s object: %s, size: %d\n", action, obj.ObjectName(), n)
	return n, nil
}

// readObject read GCS object and return raw bytes
func readObject(bucket, key string) ([]byte, error) {
	ctx := context.Background()
	ctxTO, cancel := context.WithTimeout(ctx, time.Second*10)
	defer cancel()

	client, err := storage.NewClient(ctx)
	if err != nil {
		return nil, fmt.Errorf("storage.NewClient: %v", err)
	}
	defer client.Close()

	rc, err := client.Bucket(bucket).Object(key).NewReader(ctxTO)
	if err != nil {
		return nil, fmt.Errorf("object(%q).NewReader: %v", key, err)
	}
	defer rc.Close()

	raw, err := io.ReadAll(rc)
	if err != nil {
		return nil, fmt.Errorf("io.ReadAll: %v", err)
	}
	log.Printf("read object %v complete, size %v.\n", key, len(raw))
	return raw, nil
}
